/**
 * Daemon Shutdown Handler
 * 세션 종료 시 마무리 작업: worklog + metrics + flush + cleanup.
 * 기존 auto-worklog.sh + auto-metrics.sh 로직을 TypeScript로 대체.
 */

import path from 'path';
import fs from 'fs-extra';
import { getTimestamp } from '../utils/date.js';
import type { IncrementalMetrics } from './jsonl-watcher.js';

/**
 * 세션 종료 시 worklog markdown 생성
 * (기존 auto-worklog.sh 대체)
 */
export async function generateWorklog(
  projectRoot: string,
  sessionLogPath: string | null,
  sessionShort: string,
): Promise<void> {
  if (!sessionLogPath || !await fs.pathExists(sessionLogPath)) return;

  const today = new Date().toISOString().split('T')[0];
  const logDir = path.join(projectRoot, '.timsquad', 'logs');
  await fs.ensureDir(logDir);
  const outPath = path.join(logDir, `${today}-session.md`);

  try {
    const content = await fs.readFile(sessionLogPath, 'utf-8');
    const lines = content.split('\n').filter(l => l.trim());

    // 이벤트 통계
    const events = lines.map(l => { try { return JSON.parse(l); } catch { return null; } }).filter(Boolean);
    const toolUses = events.filter(e => e.event === 'PostToolUse');
    const failures = events.filter(e => e.event === 'PostToolUseFailure');
    const subagents = events.filter(e => e.event === 'SubagentStart');

    // 도구별 분류
    const toolCounts: Record<string, number> = {};
    for (const e of toolUses) {
      const tool = e.tool || 'unknown';
      toolCounts[tool] = (toolCounts[tool] || 0) + 1;
    }

    // 변경 파일 수집
    const changedFiles = new Set<string>();
    for (const e of events) {
      if (e.detail?.file_path) changedFiles.add(e.detail.file_path);
    }

    // markdown 생성
    let md = `# Session Log - ${today} (${sessionShort})\n\n`;
    md += `> Auto-generated by tsq daemon\n\n`;
    md += `## Summary\n\n`;
    md += `| Metric | Value |\n|--------|-------|\n`;
    md += `| Events | ${events.length} |\n`;
    md += `| Tool Uses | ${toolUses.length} |\n`;
    md += `| Failures | ${failures.length} |\n`;
    md += `| Subagents | ${subagents.length} |\n`;
    md += `| Files Touched | ${changedFiles.size} |\n`;
    md += `\n`;

    if (Object.keys(toolCounts).length > 0) {
      md += `## Tool Usage\n\n`;
      md += `| Tool | Count |\n|------|-------|\n`;
      for (const [tool, count] of Object.entries(toolCounts).sort((a, b) => b[1] - a[1])) {
        md += `| ${tool} | ${count} |\n`;
      }
      md += `\n`;
    }

    if (changedFiles.size > 0) {
      md += `## Modified Files\n\n`;
      for (const f of Array.from(changedFiles).sort()) {
        md += `- ${f}\n`;
      }
      md += `\n`;
    }

    // 기존 파일에 append
    if (await fs.pathExists(outPath)) {
      const existing = await fs.readFile(outPath, 'utf-8');
      md = existing + '\n---\n\n' + md;
    }
    await fs.writeFile(outPath, md);
  } catch {
    // worklog 생성 실패 무시
  }
}

/**
 * 메트릭 latest.json 갱신
 * (기존 auto-metrics.sh 대체)
 */
export async function updateMetrics(
  projectRoot: string,
  metrics: IncrementalMetrics,
  sessionShort: string,
): Promise<void> {
  const metricsDir = path.join(projectRoot, '.timsquad', 'retrospective', 'metrics');
  await fs.ensureDir(metricsDir);

  const latestFile = path.join(metricsDir, 'latest.json');
  const today = new Date().toISOString().split('T')[0];

  // 기존 값 로드
  let existing: Record<string, unknown> = {};
  if (await fs.pathExists(latestFile)) {
    try {
      existing = await fs.readJson(latestFile);
    } catch {
      existing = {};
    }
  }

  const prev = {
    sessions: (existing.totalSessions as number) || 0,
    events: (existing.totalEvents as number) || 0,
    toolUses: (existing.totalToolUses as number) || 0,
    failures: (existing.totalFailures as number) || 0,
    subagents: (existing.subagentCount as number) || 0,
    bash: ((existing.cliAdoption as Record<string, number>)?.totalBashCommands) || 0,
    tsq: ((existing.cliAdoption as Record<string, number>)?.tsqCommands) || 0,
  };

  const totalEvents = metrics.toolUses + metrics.toolFailures + metrics.subagentCount;
  const newSessions = prev.sessions + 1;
  const newToolUses = prev.toolUses + metrics.toolUses;
  const newFailures = prev.failures + metrics.toolFailures;
  const newBash = prev.bash + metrics.bashCommands;
  const newTsq = prev.tsq + metrics.tsqCommands;

  const totalAttempts = newToolUses + newFailures;
  const toolEfficiency = totalAttempts > 0 ? Math.round(newToolUses * 100 / totalAttempts) : 0;
  const cliAdoption = newBash > 0 ? Math.round(newTsq * 100 / newBash) : 0;

  const result = {
    updatedAt: getTimestamp(),
    lastDate: today,
    lastSession: sessionShort,
    totalSessions: newSessions,
    totalEvents: prev.events + totalEvents,
    totalToolUses: newToolUses,
    totalFailures: newFailures,
    toolEfficiency,
    subagentCount: prev.subagents + metrics.subagentCount,
    tokens: {
      totalInput: metrics.tokenInput,
      totalOutput: metrics.tokenOutput,
      totalCacheCreate: metrics.tokenCacheCreate,
      totalCacheRead: metrics.tokenCacheRead,
      cacheHitRate: 0,
    },
    cliAdoption: {
      totalBashCommands: newBash,
      tsqCommands: newTsq,
      adoptionRate: cliAdoption,
    },
  };

  await fs.writeJson(latestFile, result, { spaces: 2 });
}

/**
 * PID 파일 + 소켓 정리
 */
export async function cleanupDaemonFiles(projectRoot: string): Promise<void> {
  const pidFile = path.join(projectRoot, '.timsquad', '.daemon.pid');
  const sockFile = path.join(projectRoot, '.timsquad', '.daemon.sock');
  const contextFile = path.join(projectRoot, '.timsquad', '.daemon', 'task-context.json');

  for (const f of [pidFile, sockFile, contextFile]) {
    try { await fs.remove(f); } catch { /* ok */ }
  }
}
